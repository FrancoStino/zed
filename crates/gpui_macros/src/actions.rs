use proc_macro::TokenStream;
use proc_macro2::{Ident, TokenStream as TokenStream2};
use quote::quote;
use syn::{
    Attribute, Path, Token,
    parse::{Parse, ParseStream},
    parse_macro_input,
    punctuated::Punctuated,
};

/// Common code generation for all action types
fn generate_action_impl(
    name: &Ident,
    visual_name: &str,
    build_fn: TokenStream2,
    json_schema_fn: TokenStream2,
    deprecated_aliases_fn: Option<TokenStream2>,
) -> TokenStream2 {
    let deprecated_aliases_impl = if let Some(aliases_fn) = deprecated_aliases_fn {
        aliases_fn
    } else {
        quote! {
            fn deprecated_aliases() -> &'static [&'static str] {
                &[]
            }
        }
    };

    quote! {
        impl gpui::Action for #name {
            fn name(&self) -> &'static str {
                #visual_name
            }

            fn debug_name() -> &'static str
            where
                Self: ::std::marker::Sized
            {
                #visual_name
            }

            fn partial_eq(&self, action: &dyn gpui::Action) -> bool {
                action
                    .as_any()
                    .downcast_ref::<Self>()
                    .map_or(false, |a| self == a)
            }

            fn boxed_clone(&self) -> std::boxed::Box<dyn gpui::Action> {
                ::std::boxed::Box::new(self.clone())
            }

            #build_fn

            #json_schema_fn

            #deprecated_aliases_impl
        }
    }
}

/// Helper to check if attributes contain a doc comment
fn has_doc_comment(attrs: &[Attribute]) -> bool {
    attrs.iter().any(|attr| attr.path().is_ident("doc"))
}

/// Helper to generate default doc comment
fn generate_default_doc(name: &Ident) -> TokenStream2 {
    let doc_string = format!("`{}` action generated by `gpui::actions!`", name);
    quote! { #[doc = #doc_string] }
}

struct ActionDef {
    attrs: Vec<Attribute>,
    name: Ident,
    impl_only: bool,
    no_json: bool,
    deprecated_aliases: Vec<Path>,
    visual_name: Option<Path>,
}

impl ActionDef {
    fn parse_from_attributes(attrs: Vec<Attribute>, name: Ident) -> syn::Result<Self> {
        let mut impl_only = false;
        let mut no_json = false;
        let mut deprecated_aliases = Vec::new();
        let mut visual_name = None;
        let mut remaining_attrs = Vec::new();

        for attr in attrs {
            if attr.path().is_ident("impl_only") {
                impl_only = true;
            } else if attr.path().is_ident("no_json") {
                no_json = true;
            } else if attr.path().is_ident("deprecated_aliases") {
                // Parse deprecated aliases as paths
                attr.parse_nested_meta(|meta| {
                    deprecated_aliases.push(meta.path);
                    Ok(())
                })?;
            } else if attr.path().is_ident("name") {
                // Parse visual name as a path
                attr.parse_nested_meta(|meta| {
                    visual_name = Some(meta.path);
                    Ok(())
                })?;
            } else {
                remaining_attrs.push(attr);
            }
        }

        Ok(ActionDef {
            attrs: remaining_attrs,
            name,
            impl_only,
            no_json,
            deprecated_aliases,
            visual_name,
        })
    }
}

struct ActionsInput {
    namespace: Path,
    actions: Vec<ActionDef>,
}

impl Parse for ActionsInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;

        let actions_group;
        syn::bracketed!(actions_group in input);

        let mut actions = Vec::new();
        let punctuated: Punctuated<_, Token![,]> = actions_group.parse_terminated(
            |input| {
                let attrs = input.call(Attribute::parse_outer)?;
                let name = input.parse()?;
                ActionDef::parse_from_attributes(attrs, name)
            },
            Token![,],
        )?;

        for action in punctuated {
            actions.push(action);
        }

        Ok(ActionsInput { namespace, actions })
    }
}

pub fn actions_macro(input: TokenStream) -> TokenStream {
    let ActionsInput { namespace, actions } = parse_macro_input!(input as ActionsInput);

    let mut output = TokenStream2::new();

    for action_def in actions {
        let ActionDef {
            attrs,
            name,
            impl_only,
            no_json,
            deprecated_aliases,
            visual_name,
        } = action_def;

        // Determine the visual name and full name string
        let full_visual_name = if let Some(ref vn) = visual_name {
            // Check if the path has multiple segments (contains namespace)
            if vn.segments.len() > 1 {
                // Full namespace provided
                quote!(#vn).to_string()
            } else {
                // Just the name provided, add current namespace
                format!("{}::{}", quote!(#namespace), quote!(#vn))
            }
        } else {
            format!("{}::{}", quote!(#namespace), name)
        };

        // Add default doc comment if needed
        let doc_attr = if !has_doc_comment(&attrs) {
            generate_default_doc(&name)
        } else {
            quote! {}
        };

        // Generate build function based on attributes
        let build_fn = if no_json {
            let error_msg = format!(
                "{} is an internal action, so cannot be built from JSON.",
                full_visual_name
            );
            quote! {
                fn build(_: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                    gpui::Result::Err(gpui::private::anyhow::anyhow!(#error_msg))
                }
            }
        } else if impl_only {
            quote! {
                fn build(value: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                    Ok(std::boxed::Box::new(gpui::private::serde_json::from_value::<Self>(value)?))
                }
            }
        } else {
            quote! {
                fn build(_: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                    Ok(Box::new(Self))
                }
            }
        };

        // Generate JSON schema function based on attributes
        let json_schema_fn = if no_json || !impl_only {
            quote! {
                fn action_json_schema(
                    _: &mut gpui::private::schemars::r#gen::SchemaGenerator,
                ) -> Option<gpui::private::schemars::schema::Schema> {
                    None
                }
            }
        } else {
            quote! {
                fn action_json_schema(
                    generator: &mut gpui::private::schemars::r#gen::SchemaGenerator,
                ) -> Option<gpui::private::schemars::schema::Schema> {
                    Some(<Self as gpui::private::schemars::JsonSchema>::json_schema(generator))
                }
            }
        };

        // Handle deprecated aliases
        let deprecated_aliases_fn = if !deprecated_aliases.is_empty() {
            // Process aliases to add namespace if missing
            let processed_aliases: Vec<String> = deprecated_aliases
                .iter()
                .map(|alias| {
                    if alias.segments.len() > 1 {
                        // Full namespace provided
                        quote!(#alias).to_string()
                    } else {
                        // Just the name provided, add current namespace
                        format!("{}::{}", quote!(#namespace), quote!(#alias))
                    }
                })
                .collect();

            Some(quote! {
                fn deprecated_aliases() -> &'static [&'static str] {
                    &[#(#processed_aliases),*]
                }
            })
        } else {
            None
        };

        // Generate action implementation
        let action_impl = generate_action_impl(
            &name,
            &full_visual_name,
            build_fn,
            json_schema_fn,
            deprecated_aliases_fn,
        );

        // Generate the full output
        let full_output = if impl_only {
            // For impl_only, just generate the impl
            quote! {
                #action_impl
                gpui::register_action!(#name);
            }
        } else {
            // For normal actions, generate the struct too
            quote! {
                #doc_attr
                #(#attrs)*
                #[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
                pub struct #name;

                #action_impl
                gpui::register_action!(#name);
            }
        };

        output.extend(full_output);
    }

    TokenStream::from(output)
}
