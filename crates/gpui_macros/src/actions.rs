use proc_macro::TokenStream;
use proc_macro2::{Ident, TokenStream as TokenStream2};
use quote::quote;
use syn::{
    Attribute, Path, Token,
    parse::{Parse, ParseStream},
    parse_macro_input,
    punctuated::Punctuated,
};

/// Common code generation for all action types
fn generate_action_impl(
    namespace: &Path,
    name: &Ident,
    visual_name: &Ident,
    build_fn: TokenStream2,
    json_schema_fn: TokenStream2,
    deprecated_aliases_fn: Option<TokenStream2>,
) -> TokenStream2 {
    let debug_name = format!("{}::{}", quote!(#namespace), visual_name);

    let deprecated_aliases_impl = if let Some(aliases_fn) = deprecated_aliases_fn {
        aliases_fn
    } else {
        quote! {
            fn deprecated_aliases() -> &'static [&'static str] {
                &[]
            }
        }
    };

    quote! {
        impl gpui::Action for #name {
            fn name(&self) -> &'static str {
                #debug_name
            }

            fn debug_name() -> &'static str
            where
                Self: ::std::marker::Sized
            {
                #debug_name
            }

            fn partial_eq(&self, action: &dyn gpui::Action) -> bool {
                action
                    .as_any()
                    .downcast_ref::<Self>()
                    .map_or(false, |a| self == a)
            }

            fn boxed_clone(&self) -> std::boxed::Box<dyn gpui::Action> {
                ::std::boxed::Box::new(self.clone())
            }

            #build_fn

            #json_schema_fn

            #deprecated_aliases_impl
        }
    }
}

/// Helper to check if attributes contain a doc comment
fn has_doc_comment(attrs: &[Attribute]) -> bool {
    attrs.iter().any(|attr| attr.path().is_ident("doc"))
}

/// Helper to generate default doc comment
fn generate_default_doc(name: &Ident) -> TokenStream2 {
    let doc_string = format!("`{}` action generated by `gpui::actions!`", name);
    quote! { #[doc = #doc_string] }
}

struct ActionDef {
    attrs: Vec<Attribute>,
    name: Ident,
}

struct ActionsInput {
    namespace: Path,
    actions: Vec<ActionDef>,
}

impl Parse for ActionsInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;

        let actions_group;
        syn::bracketed!(actions_group in input);

        let mut actions = Vec::new();
        let punctuated: Punctuated<_, Token![,]> = actions_group.parse_terminated(
            |input| {
                let attrs = input.call(Attribute::parse_outer)?;
                let name = input.parse()?;
                Ok(ActionDef { attrs, name })
            },
            Token![,],
        )?;

        for action in punctuated {
            actions.push(action);
        }

        Ok(ActionsInput { namespace, actions })
    }
}

pub fn actions_macro(input: TokenStream) -> TokenStream {
    let ActionsInput { namespace, actions } = parse_macro_input!(input as ActionsInput);

    let mut output = TokenStream2::new();

    for ActionDef { attrs, name } in actions {
        let doc_attr = if !has_doc_comment(&attrs) {
            generate_default_doc(&name)
        } else {
            quote! {}
        };

        let build_fn = quote! {
            fn build(_: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                Ok(Box::new(Self))
            }
        };

        let json_schema_fn = quote! {
            fn action_json_schema(
                _: &mut gpui::private::schemars::r#gen::SchemaGenerator,
            ) -> Option<gpui::private::schemars::schema::Schema> {
                None
            }
        };

        let action_impl =
            generate_action_impl(&namespace, &name, &name, build_fn, json_schema_fn, None);

        let full_output = quote! {
            #doc_attr
            #(#attrs)*
            #[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
            pub struct #name;

            #action_impl

            gpui::register_action!(#name);
        };

        output.extend(full_output);
    }

    TokenStream::from(output)
}

struct ActionAsInput {
    attrs: Vec<Attribute>,
    namespace: Path,
    name: Ident,
    visual_name: Ident,
}

impl Parse for ActionAsInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let attrs = input.call(Attribute::parse_outer)?;
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;
        let name = input.parse()?;
        input.parse::<Token![as]>()?;
        let visual_name = input.parse()?;

        Ok(ActionAsInput {
            attrs,
            namespace,
            name,
            visual_name,
        })
    }
}

pub fn action_as_macro(input: TokenStream) -> TokenStream {
    let ActionAsInput {
        attrs,
        namespace,
        name,
        visual_name,
    } = parse_macro_input!(input as ActionAsInput);

    let doc_attr = if !has_doc_comment(&attrs) {
        generate_default_doc(&name)
    } else {
        quote! {}
    };

    let build_fn = quote! {
        fn build(_: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
            Ok(Box::new(Self))
        }
    };

    let json_schema_fn = quote! {
        fn action_json_schema(
            _: &mut gpui::private::schemars::r#gen::SchemaGenerator,
        ) -> Option<gpui::private::schemars::schema::Schema> {
            None
        }
    };

    let action_impl = generate_action_impl(
        &namespace,
        &name,
        &visual_name,
        build_fn,
        json_schema_fn,
        None,
    );

    let output = quote! {
        #doc_attr
        #(#attrs)*
        #[derive(
            ::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug, ::std::cmp::PartialEq,
        )]
        pub struct #name;

        #action_impl

        gpui::register_action!(#name);
    };

    TokenStream::from(output)
}

struct ActionWithAliasesInput {
    attrs: Vec<Attribute>,
    namespace: Path,
    name: Ident,
    aliases: Vec<String>,
}

impl Parse for ActionWithAliasesInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let attrs = input.call(Attribute::parse_outer)?;
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;
        let name = input.parse()?;
        input.parse::<Token![,]>()?;

        let aliases_group;
        syn::bracketed!(aliases_group in input);

        let mut aliases = Vec::new();
        let punctuated: Punctuated<syn::LitStr, Token![,]> =
            aliases_group.parse_terminated(|input| input.parse(), Token![,])?;

        for alias in punctuated {
            aliases.push(alias.value());
        }

        Ok(ActionWithAliasesInput {
            attrs,
            namespace,
            name,
            aliases,
        })
    }
}

pub fn action_with_deprecated_aliases_macro(input: TokenStream) -> TokenStream {
    let ActionWithAliasesInput {
        attrs,
        namespace,
        name,
        aliases,
    } = parse_macro_input!(input as ActionWithAliasesInput);

    let doc_attr = if !has_doc_comment(&attrs) {
        generate_default_doc(&name)
    } else {
        quote! {}
    };

    let build_fn = quote! {
        fn build(_: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
            Ok(Box::new(Self))
        }
    };

    let json_schema_fn = quote! {
        fn action_json_schema(
            _: &mut gpui::private::schemars::r#gen::SchemaGenerator,
        ) -> Option<gpui::private::schemars::schema::Schema> {
            None
        }
    };

    let deprecated_aliases_fn = quote! {
        fn deprecated_aliases() -> &'static [&'static str] {
            &[
                #(#aliases),*
            ]
        }
    };

    let action_impl = generate_action_impl(
        &namespace,
        &name,
        &name,
        build_fn,
        json_schema_fn,
        Some(deprecated_aliases_fn),
    );

    let output = quote! {
        #doc_attr
        #(#attrs)*
        #[derive(
            ::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug, ::std::cmp::PartialEq,
        )]
        pub struct #name;

        #action_impl

        gpui::register_action!(#name);
    };

    TokenStream::from(output)
}

// Additional input structs for the new macros

struct ImplActionsInput {
    namespace: Path,
    names: Vec<Ident>,
}

impl Parse for ImplActionsInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;

        let names_group;
        syn::bracketed!(names_group in input);

        let names: Punctuated<Ident, Token![,]> =
            names_group.parse_terminated(|input| input.parse(), Token![,])?;

        Ok(ImplActionsInput {
            namespace,
            names: names.into_iter().collect(),
        })
    }
}

pub fn impl_actions_macro(input: TokenStream) -> TokenStream {
    let ImplActionsInput { namespace, names } = parse_macro_input!(input as ImplActionsInput);

    let mut output = TokenStream2::new();

    for name in names {
        let build_fn = quote! {
            fn build(value: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                Ok(std::boxed::Box::new(gpui::private::serde_json::from_value::<Self>(value)?))
            }
        };

        let json_schema_fn = quote! {
            fn action_json_schema(
                generator: &mut gpui::private::schemars::r#gen::SchemaGenerator,
            ) -> Option<gpui::private::schemars::schema::Schema> {
                Some(<Self as gpui::private::schemars::JsonSchema>::json_schema(generator))
            }
        };

        let action_impl =
            generate_action_impl(&namespace, &name, &name, build_fn, json_schema_fn, None);

        let full_output = quote! {
            #action_impl

            gpui::register_action!(#name);
        };

        output.extend(full_output);
    }

    TokenStream::from(output)
}

struct ImplActionAsInput {
    namespace: Path,
    name: Ident,
    visual_name: Ident,
}

impl Parse for ImplActionAsInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let namespace = input.parse()?;
        input.parse::<Token![,]>()?;
        let name = input.parse()?;
        input.parse::<Token![as]>()?;
        let visual_name = input.parse()?;

        Ok(ImplActionAsInput {
            namespace,
            name,
            visual_name,
        })
    }
}

pub fn impl_action_as_macro(input: TokenStream) -> TokenStream {
    let ImplActionAsInput {
        namespace,
        name,
        visual_name,
    } = parse_macro_input!(input as ImplActionAsInput);

    let build_fn = quote! {
        fn build(value: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
            Ok(std::boxed::Box::new(gpui::private::serde_json::from_value::<Self>(value)?))
        }
    };

    let json_schema_fn = quote! {
        fn action_json_schema(
            generator: &mut gpui::private::schemars::r#gen::SchemaGenerator,
        ) -> Option<gpui::private::schemars::schema::Schema> {
            Some(<Self as gpui::private::schemars::JsonSchema>::json_schema(generator))
        }
    };

    let action_impl = generate_action_impl(
        &namespace,
        &name,
        &visual_name,
        build_fn,
        json_schema_fn,
        None,
    );

    let output = quote! {
        #action_impl

        gpui::register_action!(#name);
    };

    TokenStream::from(output)
}

pub fn impl_internal_actions_macro(input: TokenStream) -> TokenStream {
    let ImplActionsInput { namespace, names } = parse_macro_input!(input as ImplActionsInput);

    let mut output = TokenStream2::new();

    for name in names {
        let error_message = format!(
            "{}::{} is an internal action, so cannot be built from JSON.",
            quote!(#namespace),
            name
        );

        let build_fn = quote! {
            fn build(_value: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
                gpui::Result::Err(gpui::private::anyhow::anyhow!(#error_message))
            }
        };

        let json_schema_fn = quote! {
            fn action_json_schema(
                _generator: &mut gpui::private::schemars::r#gen::SchemaGenerator,
            ) -> Option<gpui::private::schemars::schema::Schema> {
                None
            }
        };

        let action_impl =
            generate_action_impl(&namespace, &name, &name, build_fn, json_schema_fn, None);

        output.extend(action_impl);
    }

    TokenStream::from(output)
}

pub fn impl_action_with_deprecated_aliases_macro(input: TokenStream) -> TokenStream {
    let ActionWithAliasesInput {
        attrs: _, // We don't expect attributes on this macro
        namespace,
        name,
        aliases,
    } = parse_macro_input!(input as ActionWithAliasesInput);

    let build_fn = quote! {
        fn build(value: gpui::private::serde_json::Value) -> gpui::Result<::std::boxed::Box<dyn gpui::Action>> {
            Ok(std::boxed::Box::new(gpui::private::serde_json::from_value::<Self>(value)?))
        }
    };

    let json_schema_fn = quote! {
        fn action_json_schema(
            generator: &mut gpui::private::schemars::r#gen::SchemaGenerator,
        ) -> Option<gpui::private::schemars::schema::Schema> {
            Some(<Self as gpui::private::schemars::JsonSchema>::json_schema(generator))
        }
    };

    let deprecated_aliases_fn = quote! {
        fn deprecated_aliases() -> &'static [&'static str] {
            &[
                #(#aliases),*
            ]
        }
    };

    let action_impl = generate_action_impl(
        &namespace,
        &name,
        &name,
        build_fn,
        json_schema_fn,
        Some(deprecated_aliases_fn),
    );

    let output = quote! {
        #action_impl

        gpui::register_action!(#name);
    };

    TokenStream::from(output)
}
